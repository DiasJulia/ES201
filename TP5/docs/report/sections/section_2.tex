\section*{Architecture multicoeurs avec des processeurs superscalaires in-order (Cortex A7)}

\subsection*{Q4 : Déterminez quel est le processeur exécutant toujours le plus grand nombre de
cycles. Expliquez pourquoi. Expliquez également pourquoi l’analyse du nombre de cycles sur
ce processeur revient à analyser le nombre total de cycles d’exécution de l’application.}

L'expérience (voir code) nous montre que c'est toujours \texttt{cpu0}. En effet, cela se comprend car dans une application OpenMP, l'exécution se déroule en deux phases :
\begin{itemize}
    \item \textbf{La phase séquentielle :} Elle est exécutée uniquement par le thread maître (\texttt{cpu0}). C'est lui qui initialise les données, alloue la mémoire et orchestre les threads.
    \item \textbf{La phase parallèle :} La charge de travail est répartie entre tous les CPUs.
\end{itemize}

\texttt{cpu0} cumule donc les deux charges (séquentielle + une part de la parallèle), ce qui lui donne systématiquement un nombre de cycles plus élevé que les autres processeurs.

À cause de la \textbf{barrière de synchronisation} OpenMP située en fin de bloc parallèle : tous les threads doivent impérativement l'atteindre avant que le programme puisse poursuivre son exécution. La durée totale de l'application est donc déterminée par la durée du thread le plus lent (le "chemin critique"), qui est ici toujours \texttt{cpu0}.

\subsection*{Q5 : Pour chaque configuration, quel est le nombre de cycles d’exécution de l’application
? Vous pourrez présenter vos résultats sous forme de graphe 2 axes}

\subsubsection*{Tableau des nombres de cycles maximums}

\begin{center}
\begin{tabularx}{\textwidth}{lX r}
\toprule
\textbf{Nombre de Threads} & \textbf{CPU identifié} & \textbf{Nombre de Cycles (Max)} \\
\midrule
1  & system.cpu.numCycles  & 4 140 593 \\
2  & system.cpu0.numCycles & 2 147 905 \\
4  & system.cpu0.numCycles & 1 151 585 \\
8  & system.cpu0.numCycles & 653 929   \\
16 & system.cpu00.numCycles & 406 212   \\
32 & system.cpu00.numCycles & 284 352   \\
64 & system.cpu00.numCycles & 227 503   \\
\bottomrule
\end{tabularx}
\end{center}

\begin{figure}[htbp]
    \centering
    \fbox{
        \includegraphics[width=0.7\linewidth]{./plots/cycles.png}
    }
    \caption{Courbe du nombre de cycle maximum (cpu0) en fonction du nombre de threads}
    \label{fig:ipc_speedup}
\end{figure}

\newpage

\subsection*{Q6 : Déduire le speedup par rapport à la configuration à 1 thread.}

La formule du SpeedUp est donnée par : 
\begin{equation}
    SpeedUp = \frac{cpu0.numCycles[\text{1 thread}]}{cpu0.numCycles[\text{n threads}]}
\end{equation}

\subsection*{Évolution du SpeedUp}

\begin{center}
\begin{tabular}{cc}
\toprule
\textbf{Threads} & \textbf{SpeedUp} \\
\midrule
1  & 1,000 \\
2  & 1,928 \\
4  & 3,596 \\
8  & 6,332 \\
16 & 10,193 \\
32 & 14,562 \\
64 & 18,200 \\
\bottomrule
\end{tabular}
\end{center}

\begin{figure}[htbp]
    \centering
    \fbox{
        \includegraphics[width=0.7\linewidth]{./plots/speedup.png}
    }
    \caption{Courbe du SpeedUp en fonction du nombre de threads}
    \label{fig:ipc_speedup}
\end{figure}

\newpage

\subsection*{Q7 : En utilisant le nombre total d’instructions simulées, déterminez quelle est la valeur
maximale de l’IPC pour chaque configuration ?}

La formule de l'IPC (Instructions Per Cycle) est :
\begin{equation}
    IPC = \frac{sim\_insts}{cpu0.numCycles}
\end{equation}

Le nombre d'instructions \texttt{sim\_insts} reste constant quelle que soit la configuration (on effectue toujours le même calcul sur une matrice de taille 64). Quand le nombre de threads augmente, \texttt{cpu0.numCycles} diminue car le travail est mieux réparti, par conséquent l'IPC augmente. L'IPC maximal est atteint pour la configuration avec le plus grand nombre de threads.

\subsection*{Résultats de l'IPC}

\begin{center}
\begin{tabular}{cc}
\toprule
\textbf{Threads} & \textbf{IPC Max} \\
\midrule
1  & 0,992 \\
2  & 1,914 \\
4  & 3,572 \\
8  & 6,304 \\
16 & 10,213 \\
32 & 14,885 \\
64 & 19,907 \\
\bottomrule
\end{tabular}
\end{center}

\begin{figure}[htbp]
    \centering
    \fbox{
        \includegraphics[width=0.7\linewidth]{./plots/ipc.png}
    }
    \caption{Courbe de l'IPC en fonction du nombre de threads}
    \label{fig:ipc_speedup}
\end{figure}

\newpage

\subsection*{Q8 : Discussion et interprétation (max. 10 lignes).}

D'après les résultats obtenus, on observe que le nombre de cycles de l'application diminue lorsque le nombre de threads augmente, ce qui se traduit par un speedup croissant. Cependant, ce speedup reste inférieur au speedup idéal (linéaire), ce qui s'explique par la loi d'Amdahl : une partie du code reste séquentielle (exécutée uniquement par cpu0) et constitue un goulot d'étranglement irréductible.
On remarque également que l'IPC augmente avec le nombre de threads, ce qui est cohérent : cpu0 exécute le même nombre d'instructions en moins de cycles, donc son efficacité augmente. Les courbes de speedup et d'IPC sont corrélées car toutes deux sont inversement proportionnelles à cpu0.numCycles.

Au-delà d'un certain nombre de threads (typiquement au-delà de m/4), le gain devient marginal : le surcoût de synchronisation aux barrières OpenMP et le déséquilibre de charge entre cpu0 et les autres CPUs limitent les gains. Pour une matrice de taille 64, la configuration optimale se situe donc entre 8 et 16 threads, au-delà desquels le speedup stagne.
